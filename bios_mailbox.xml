<mailbox xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:noNamespaceSchemaLocation="mailbox.xsd">
  <type>bios</type>
  <endpoint name="bios/os/bmc" dir="in" />
  <version major="3" minor="9" doc_ver="0"/>
  <version_log>
    | Version | Comment                                                                                                                                       | Date        |
    | :-----: | ----------------------------------------------                                                                                                | :-----:     |
    | 2.x.x   | Eaglestream ( GNR/SRF )                                                                                                                       |             |
    | 3.0.0   | New version for DMR/Oakstream platform                                                                                                        |             |
    | 3.1.0   | Removed GNR specific IA_MODULE_GLOBAL_ENABLE_MASK and IA_MODULE_GLOBAL_TO_LOCAL_INSTANCE commands. Added IMH mesh to SET_CORE_MESH_RATIO      |             |
    | 3.1.1   | Clarified SET_CORE_MESH_RATIO - BSP_TURBO will set other cores to Pn, not Pmin.                                                               |             |
    | 3.2.0   | Added READ/WRITE_PM_CONFIG PROG_SSC_CONTROL subcommand                                                                                        | Jun 12 2023 |
    | 3.2.1   | Added clarification to OC_TJ_MAX_OFFSET command                                                                                               | Jun 15 2023 |
    | 3.3.0   | Removed OC related commands (OC_TJ_MAX_OFFSET and PER_MODULE_LP_ENABLE) and MULTI_SKT_UPD                                                     | Aug 28 2023 |
    | 3.3.2   | Added PCU_MISC_CONFIG.CLTT_MR4_ENABLE, update ENHANCED_ADR.set_ratio command                                                                  | Sep 01 2023 |
    | 3.3.3   | Clarified behavior of READ_PM_CONFIG.MIN_ICCP_LEVEL                                                                                           | Sep 18 2023 |
    | 3.4.0   | Added SPD_RECOVERY_CTL command                                                                                                                | Sep 22 2023 |
    | 3.4.1   | Clarified SET_CORE_MESH_RATIO.read behavior. Added retrun code when PM_MISC_CONTROL.THERM_MONITOR_STATUS is locked                            | Oct 03 2023 |
    | 3.4.2   | Fixed typo in SET_CORE_MESH_RATIO description text. READ is sub-command 1 not 3. No change to command itself                                  | Oct 05 2023 |
    | 3.5.0   | Added DDR_SUB_CHANNEL to ADDDC_QUIESCE command. Clarified SET_CORE_MESH_RATIO for Workhorse (non-BSP) cores                                   | Oct 10 2023 |
    | 3.5.1   | Set PSYS_CONFIG to lock at CPL3                                                                                                               | Nov  6 2023 |
    | 3.5.2   | Added die type="IO/MEM/COMPUTE" to commands. If not specified, it is serviced on all die                                                      | Nov 16 2023 |
    | 3.5.3   | (UN)QUIESCE_PECI and RAS_START/EXIT serviced on IO only. OOB_INIT_EPP on Compute only                                                         | Dec  8 2023 |
    | 3.5.4   | Removed GET_VERSION PATCH sub-command.                                                                                                        | Dec 19 2023 |
    | 3.6.0   | Deprecated SET_MC_FREQ, READ_MC_FREQ, READ_MC_VOLTAGE commands. Added enums for all READ_WRITE fields                                         | Jan  3 2023 |
    | 3.7.0   | Added SINGLE_DIMM_MODE_OEM to READ_PKG_CONFIG.MC_DDR_MASK subcommand                                                                          | Jan 29 2023 |
    | 3.8.0   | Removed READ_PKG_CONFIG.enabled_upi_link_id_mask, MISC_WORKAROUND_ENALBE.cxl_test_card_pkgs_wa_enable. Extended SPD_RECOVER_CTL for 8 SPD bus | Mar  7 2024 |
    | 3.9.0   | Aligned SPD_RECOVERY_CTL to the GNR definition spd bits are in the data field                                                                 | Mar 18 2024 |
    | 3.10.0  | Added a new subcommand UFS_OPTIMIZATION_DISABLE(0x9) to READ/WRITE_PM_CONFIG. Not valid for DMR.                                              | Jun 21 2024 |
  </version_log>
  <commands>
    <command>
      <name>ZERO</name>
      <opcode>0x0</opcode>
      <desc>The zero command; does nothing</desc>
      <bwg>Yes</bwg>
      <mbox_access access_type="RW" mbox="OS" />
      <notes>This command functions as a NOP.
        This command returns no data.
        This command returns no error code.</notes>
    </command>
    <command>
      <name>GET_VERSION</name>
      <opcode>0x1</opcode>
      <desc>The command is used to obtain the version number corresponding to the command set in the Primecode firmware image.</desc>
      <bwg>Yes</bwg>
      <interface>
        <field>
          <name>SUB_COMMAND</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc>Subcommands enumerated below</desc>
          <enum desc="Major Minor Build Version" key="MAJOR_MINOR_BUILD" val="0x0" bwg="Yes"/>
        </field>
      </interface>
      <data dir="out" key="MAJOR_MINOR_BUILD">
        <field>
          <name>BUILD_VERSION</name>
          <lsb>0</lsb>
          <num_bits>16</num_bits>
          <desc>Reserved. This field will always return 0</desc>
        </field>
        <field>
          <name>MINOR_VERSION</name>
          <lsb>16</lsb>
          <num_bits>8</num_bits>
          <desc>MINOR version is incremented when there are a small number of changes made in a backward compatible manner. A field is expanded for an opcode, a new command is added using a free (unused) opcode, or other additions to the command interface (format) in a compatible manner. These changes are not expected to break existing BIOS code; however, BIOS code might need to be updated to utilize the new interface updates.
            May include BUILD level changes.
            BUILD version is reset to 0 when MINOR version is incremented.</desc>
        </field>
        <field>
          <name>MAJOR_VERSION</name>
          <lsb>24</lsb>
          <num_bits>8</num_bits>
          <desc>MAJOR version is incremented when there are multiple changes to existing command Opcodes or command formats in a backward incompatible manner. This could be due to command cleanup, new features functionality, or other major functional changes to the command interface (format). These changes could break existing BIOS implementations and would require a BIOS code update.
            May include MINOR and BUILD level changes.
            MINOR and BUILD version is reset to 0 when MAJOR version is incremented.</desc>
        </field>
      </data>
      <notes>
        Version numbers help track developments in the command set and are assigned in increasing order.


        ERROR CODE:
        --NO_ERROR
      </notes>
    </command>
    <command>
      <name>READ_PCU_MISC_CONFIG</name>
      <opcode>0x5</opcode>
      <desc>Read misc config bits for the PCU</desc>
      <bwg>Yes</bwg>
      <data dir="out">
        <duplicate command="WRITE_PCU_MISC_CONFIG" dir="in">PCU_MISC_CONFIG</duplicate>
      </data>
      <notes>This command returns the value from the MISC_CONFIG memory variable that has the following: Refer to the WRITE_PCU_MISC_CONFIG command for the bit definitions.</notes>
    </command>
    <command>
      <name>WRITE_PCU_MISC_CONFIG</name>
      <opcode>0x6</opcode>
      <desc>Write misc config bits for the PCU</desc>
      <bwg>Yes</bwg>
      <data dir="in" storage="reset">
        <name>PCU_MISC_CONFIG</name>
        <field>
          <name>PL2_SAFETY_NET_ENABLE</name>
          <lsb>1</lsb>
          <num_bits>1</num_bits>
          <desc>PL2 Safety Net Enable. Default value is 1</desc>
        </field>
        <field>
          <name>FCT_DISABLE</name>
          <lsb>3</lsb>
          <num_bits>1</num_bits>
          <desc>Favored Core Turbo Disable</desc>
        </field>
        <field>
          <name>TXT_ENABLE</name>
          <lsb>4</lsb>
          <num_bits>1</num_bits>
          <desc>Trusted Execution Technology Enable</desc>
        </field>
        <field>
          <name>CLTT_MR4_ENABLE</name>
          <lsb>5</lsb>
          <num_bits>1</num_bits>
          <desc> To enable/disable CLTT using MR4 registers. Disabled by default.</desc>
        </field>
        <field>
          <name>CLTT_PECI_ENABLE</name>
          <lsb>6</lsb>
          <num_bits>1</num_bits>
          <desc> To enable/disable CLTT with PECI. Disabled by default. CLTT_MR4_ENABLE has precedence over this bit.</desc>
        </field>
        <field>
          <name>EPB_PECI_OVERRIDE_ENABLE</name>
          <lsb>7</lsb>
          <num_bits>1</num_bits>
          <desc> BIOS to set this bit to consider EPB override from PECI.</desc>
        </field>
        <field>
          <name>APS_ROCKET_DISABLE</name>
          <lsb>8</lsb>
          <num_bits>1</num_bits>
          <desc>APS Rocketing Disable</desc>
        </field>
        <field>
          <name>IERR_ADR_FIX_ENABLE</name>
          <lsb>12</lsb>
          <num_bits>1</num_bits>
          <desc>Enable self refresh in IERR flow</desc>
          <enum desc="No self refresh in IERR flow" key="DISABLE" val="0x0" />
          <enum desc="Force self refresh in IERR flow" key="ENABLE" val="0x1" />
        </field>
        <field>
          <name>PMAX_DISABLE</name>
          <lsb>23</lsb>
          <num_bits>1</num_bits>
          <desc>Disable Pmax detector circuit (once disabled cannot be re-enabled)</desc>
        </field>
        <field>
          <name>LIMIT_PA_TO_46</name>
          <lsb>25</lsb>
          <num_bits>1</num_bits>
          <desc>0 = Disable, 1 = Enable, When enabled it will limit the Physical address for the OS to be of 46 bits range</desc>
        </field>
        <field>
          <name>E2E_PARITY_ENABLE</name>
          <lsb>26</lsb>
          <num_bits>1</num_bits>
          <desc>Enables E to E parity</desc>
        </field>
        <field>
          <name>PCIE_DRAM_HOTPLUG_DISABLE</name>
          <lsb>27</lsb>
          <num_bits>1</num_bits>
          <desc>For disabling PCIE DRAM hotplug polling in pkg maint</desc>
        </field>
        <field>
          <name>VROD</name>
          <lsb>29</lsb>
          <num_bits>1</num_bits>
          <desc>1 = VR on DIMM, 0 = VR on MBVR</desc>
        </field>
      </data>
      <notes>This command is used to write the PCU configuration bits config registers.
        Unless noted otherwise, the reset/default value of each bit defined in BIOS to PCODE - Data table is zero (0)
        The data register is not modified when PrimeCode responds to BIOS. The data register will contain the input DATA that was recieved from BIOS regardless of the completion status (NO_ERROR/ILLEGAL_DATA)
        ERROR CODE:
        NO_ERROR
        ILLEGAL_DATA----If illegal data bits are set by BIOS.
      </notes>
    </command>
    <command>
      <name>SVID_VR_HANDLER</name>
      <opcode>0x7</opcode>
      <desc>This command is used for getting and setting of multiple VR related configuration settings.</desc>
      <bwg>Yes</bwg>
      <die type="IO"/>
      <interface>
        <field>
          <name>SUB_COMMAND</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc>Subcommands enumerated below</desc>
          <enum desc="Data: LL  resistance U12.12.0(0.001 mohm unit)-BIOS CPL PHASE: No restrictions." key="GET_ACDC_LOADLINE" val="0x1" bwg="Yes"/>
          <enum desc="Data: LL  resistance U12.12.0(0.001 mohm unit)-BIOS CPL PHASE: Locked post CPL4 phase" key="SET_ACDC_LOADLINE" val="0x2" bwg="Yes"/>
          <enum desc="Data: DATA[15:0]  IMON_OFFSET S7.8, Data: DATA[31:16] IMON_SLOPE_CORRECTION U4.12-Locked post CPL4 phase" key="SET_IMON_CONFIG" val="0x4" bwg="Yes"/>
          <enum desc="Data: DATA[15:0]  IMON_OFFSET S7.8 CPL PHASE: No restrictions" key="GET_IMON_CONFIG" val="0x14" bwg="Yes"/>
        </field>
        <field>
          <name>VR_ADDRESS</name>
          <lsb>16</lsb>
          <num_bits>5</num_bits>
          <desc>Physical VR_ADDRESS. Format:

            | Range | Description       |
            | :---: | ----------------- |
            | 4:4   | SVID Bus selector |
            | 3:0   | VR Address        |
            \n

          </desc>
        </field>
      </interface>
      <data dir="in" key="GET_ACDC_LOADLINE">
        <field>
          <name>DATA</name>
          <lsb>0</lsb>
          <num_bits>32</num_bits>
          <desc>Dont care</desc>
        </field>
      </data>
      <data dir="in" key="SET_ACDC_LOADLINE">
        <field>
          <name>DATA</name>
          <lsb>0</lsb>
          <num_bits>32</num_bits>
          <desc>Data: LL  resistance U12.12.0(0.001 mohm unit)</desc>
        </field>
      </data>
      <data dir="in" key="GET_IMON_CONFIG">
        <field>
          <name>DATA</name>
          <lsb>0</lsb>
          <num_bits>32</num_bits>
          <desc>Dont care</desc>
        </field>
      </data>
      <data dir="in" key="SET_IMON_CONFIG">
        <field>
          <name>IMON_OFFSET</name>
          <lsb>0</lsb>
          <num_bits>16</num_bits>
          <desc>Imon offset in S7.8 format</desc>
        </field>
        <field>
          <name>IMON_SLOPE</name>
          <lsb>16</lsb>
          <num_bits>16</num_bits>
          <desc>Imon slope in U4.12 format</desc>
        </field>
      </data>
      <data dir="out" key="GET_ACDC_LOADLINE">
        <field>
          <name>DATA</name>
          <lsb>0</lsb>
          <num_bits>32</num_bits>
          <desc>Data: LL  resistance U12.12.0(0.001 mohm unit)</desc>
        </field>
      </data>
      <data dir="out" key="SET_ACDC_LOADLINE">
        <field>
          <name>DATA</name>
          <lsb>0</lsb>
          <num_bits>32</num_bits>
          <desc>Dont care</desc>
        </field>
      </data>
      <data dir="out" key="GET_IMON_CONFIG">
        <field>
          <name>IMON_OFFSET</name>
          <lsb>0</lsb>
          <num_bits>16</num_bits>
          <desc>Imon offset in S7.8 format</desc>
        </field>
        <field>
          <name>IMON_SLOPE</name>
          <lsb>16</lsb>
          <num_bits>16</num_bits>
          <desc>Imon slope in U4.12 format</desc>
        </field>
      </data>
      <data dir="out" key="SET_IMON_CONFIG">
        <field>
          <name>DATA</name>
          <lsb>0</lsb>
          <num_bits>32</num_bits>
          <desc>Dont care</desc>
        </field>
      </data>
      <notes>
        All the SET_*  subcommands cannot be executed once RESET_CPL4 phase is completed.
        Command also referred to as VR_HANDLER.
        For GET/SET_ACDC_LOADLINE subcommands, VR_ADDRESS field should contain the physical address of VCCIN VR. If not, ILLEGAL_DATA completion code is returned.
        If GET_IMON_CONFIG is issued prior to any issue of SET_IMON_CONFIG, data returned is 0.

        ERROR CODE:

        * VR_INTERFACE_LOCKED
        1) Post CPL4
        * ILLEGAL_DATA
        1) Illegal data for set subcommands.
        For SET_ACDC_LOADLINE, if Primecode fuse checks fail, ILLEGAL_DATA is returned
        2) Invalid VR_ADDRESS
        * NO_ERROR
        1) If command executed successfully.
        * INVALID_COMMAND
        1) If SVID IP is not present.
      </notes>
    </command>
    <command>
      <name>BIOS_OC</name>
      <deprecated project="DMR"/>
      <opcode>0x37</opcode>
      <desc>BIOS Overclocking Interface.</desc>
      <bwg>Yes</bwg>
      <interface>
        <field>
          <name>SUB_COMMAND</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc>PARAM1:SUB_COMMAND</desc>
          <enum desc="Data: LL Read OC MISC CONFIG" key="RSVD00" val="0x0" bwg="No"/>
          <enum desc="Data: LL Write OC MISC CONFIG" key="RSVD01" val="0x1" bwg="No"/>
          <enum desc="Data: Read OC persistent overrides" key="READ_OC_PERSISTENT_OVERRIDE" val="0x2" bwg="Yes"/>
          <enum desc="Data: Client Write OC persistent overrides Server has FIVR PS DISABLE and FIVR FAULTS DISABLE in OCMB. 5:5 TSC_DISABLE_HW_FIXUP, take effect after warm reset. All others reserved" key="WRITE_OC_PERSISTENT_OVERRIDE" val="0x3" bwg="Yes"/>
          <enum desc="Data: Read TJ MAX OFFSET" key="RSVD10" val="0x4" bwg="No"/>
          <enum desc="Data: Write TJ MAX OFFSET Server implemented as different B2P command 0xAC" key="RSVD11" val="0x5" bwg="No"/>
          <enum desc="Data: DATA[15:0]  IMON_OFFSET S7.8. Domain 0x0 Core (LJPLL) 0x2 Mesh (ADPLL) 0x4 MC (ADPLL) 5:0 PLL Trim Offset" key="READ_PLL_VCC_TRIM_OFFSET" val="0x6" bwg="Yes"/>
          <enum desc="Data: DATA[15:0]  IMON_OFFSET S7.8. Domain 0x0 Core (LJPLL) 0x2 Mesh (ADPLL) 0x4 MC (ADPLL) 5:0 PLL Trim Offset" key="WRITE_PLL_VCC_TRIM_OFFSET" val="0x7" bwg="Yes"/>
          <enum desc="Data: DATA[15:0]  IMON_OFFSET S7.8. Domain 0x0 Core (LJPLL) 0x2 Mesh (ADPLL) 0x4 MC (ADPLL) 7:0 PVD Ratio Threshold" key="READ_PVD_RATIO_THRESHOLD_OVERRIDE" val="0x8" bwg="Yes"/>
          <enum desc="Data: DATA[15:0]  IMON_OFFSET S7.8. Domain 0x0 Core (LJPLL) 0x2 Mesh (ADPLL) 0x4 MC (ADPLL) 7:0 PVD Ratio Threshold. Note: Core LJPLL is only 6 bits, clip down to 6 bits. ADPLL uses all 8 bits" key="WRITE_PVD_RATIO_THRESHOLD_OVERRIDE" val="0x9" bwg="Yes"/>
          <enum desc="Data: DATA[15:0]  IMON_OFFSET S7.8" key="RSVD20" val="0xa" bwg="No"/>
          <enum desc="Data: DATA[15:0]  IMON_OFFSET S7.8" key="RSVD21" val="0xb" bwg="No"/>
        </field>
        <field>
          <name>PARAM2</name>
          <lsb>16</lsb>
          <num_bits>13</num_bits>
          <desc>DOMAIN</desc>
        </field>
      </interface>
      <data dir="in" key="WRITE_OC_PERSISTENT_OVERRIDE">
        <field>
          <name>TSC_DISABLE_HW_FIXUP</name>
          <lsb>5</lsb>
          <num_bits>1</num_bits>
          <desc>TSC_DISABLE_HW_FIXUP, take effect after warm rese</desc>
        </field>
      </data>
      <data dir="in" key="WRITE_PLL_VCC_TRIM_OFFSET">
        <field>
          <name>PLL_TRIM_OFFSET</name>
          <lsb>0</lsb>
          <num_bits>4</num_bits>
          <desc>3:0 PLL Trim Offset</desc>
        </field>
      </data>
      <data dir="in" key="WRITE_PVD_RATIO_THRESHOLD_OVERRIDE">
        <field>
          <name>PVD_RATIO_THRESHOLD</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <desc>7:0 PVD Ratio Threshold.
            Note : for Core it's only 6 bits 5:0 used since CR to be written is only 6 bit field LJPLL fuse name LJPLL_FUSE_REG_2_pvd_threshold (6bits)
            Where as for Mesh/Mem it's full 8 bits. ADPLL fuse name POST_DCO_DIV_THRESHOLD (8bits).</desc>
        </field>
      </data>
      <data dir="in">
        <field>
          <name>DATA</name>
          <lsb>0</lsb>
          <num_bits>32</num_bits>
          <desc>Data for mbx cmd</desc>
        </field>
      </data>
      <notes />
    </command>
    <command>
      <name>NEAR_TDP</name>
      <opcode>0x38</opcode>
      <desc>Set Near TDP voltage offsets</desc>
      <bwg>No</bwg>
      <mbox_access access_type="RW" mbox="OS" />
      <interface>
      </interface>
      <data dir="in">
        <field>
          <name>CORE_VOLTAGE_OFFSET</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <desc> [7:0] Core voltage offset in units of 1mV.</desc>
        </field>
        <field>
          <name>MESH_VOLTAGE_OFFSET</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc> [15:8] Mesh voltage offset in units of 1mV.</desc>
        </field>
        <field>
          <name>NAC_VOLTAGE_OFFSET</name>
          <lsb>16</lsb>
          <num_bits>8</num_bits>
          <desc> [23:16] NAC voltage offset in units of 1mV. Only applicable in GRR/GNR-D.</desc>
        </field>
      </data>
      <notes>
        Near TDP is a feature that is available to customers on sample parts along with the PTU tool.
        The PTU tool with Near TDP feature enabled will iteratively increase voltage on Core, Mesh, and any other domains exposed, until the power consumed by the part is close to TDP.
        The feature is needed to ensure that customers have a part that come close to consuming TDP, so that they can do their platform qualification.

        This feature is controlled by the  NEAR_TDP fuse.

        OPEN: Split this to sub-command to control IMH vs CBB

        Error codes:

        * NO_ERROR
        * UNSUPPORTED_COMMAND : if NEAR_TDP feature is not enabled or if flex OC lock bit is set
      </notes>
    </command>
    <command>
      <name>DFX_SCRATCHPAD</name>
      <deprecated project="DMR"/>
      <opcode>0x39</opcode>
      <desc>Provides access to a 64 DWord DFX Scratchpad</desc>
      <bwg>No</bwg>
      <die type="COMPUTE"/>
      <mbox_access access_type="RW" mbox="OS" />
      <interface>
        <field>
          <name>READ_WRITE</name>
          <lsb>8</lsb>
          <num_bits>1</num_bits>
          <desc>Specify Read/Write</desc>
          <enum desc="" key="READ"  val="0x0"/>
          <enum desc="" key="WRITE" val="0x1"/>
        </field>
        <field>
          <name>OFFSET</name>
          <lsb>16</lsb>
          <num_bits>8</num_bits>
          <desc>DWord Offset into the DFX Scratchpad</desc>
        </field>
      </interface>
      <data dir="in">
        <field>
          <name>WRITE_DATA</name>
          <lsb>0</lsb>
          <num_bits>32</num_bits>
          <desc>Scratchpad write data</desc>
        </field>
      </data>
      <data dir="out">
        <field>
          <name>READ_DATA</name>
          <lsb>0</lsb>
          <num_bits>32</num_bits>
          <desc>Scratchpad read data</desc>
        </field>
      </data>
      <notes> This command provides read/write access to a DFX Scratchpad. Note: GNR supports a 64 DWord Scratchpad. Specifying an OFFSET greater than 63 will result in an INVALID_PARAMETER completion code.
        Read/write accesses within the range 0:63 will result in a NO_ERROR completion code. Expected completions codes: 0x0 - NO_ERROR, 0x5 - INVALID_PARAMETER.</notes>
    </command>
    <command>
      <name>READ_PKG_CONFIG</name>
      <opcode>0x78</opcode>
      <desc>Provides the information on package configuration for MCHECK. It is primarily used via OS mailbox.</desc>
      <bwg>No</bwg>
      <die type="IO"/>
      <rsp_accumulation type="OR"/>
      <mbox_access access_type="RW" mbox="OS"/>
      <interface>
          <field>
              <name>SUB_COMMAND</name>
              <lsb>8</lsb>
              <num_bits>8</num_bits>
              <desc/>
              <enum desc="Returns a mask of enabled DDR Memory Controllers" key="MC_DDR_MASK" val="0x0" bwg="Yes"/>
          </field>
      </interface>
      <data dir="out" key="MC_DDR_MASK">
          <notes>This command is needed by Mcheck</notes>
          <field>
              <name>MC_DDR_MASK</name>
              <lsb>0</lsb>
              <num_bits>16</num_bits>
              <desc>Returns a mask of enabled DDR Memory Controllers. This mask reflects the resolved enabled masks of logical ids at package level, including strap disables. </desc>
          </field>
          <field>
              <name>SINGLE_DIMM_MODE_OEM</name>
              <lsb>31</lsb>
              <num_bits>1</num_bits>
              <desc>Reflects the value of the SINGLE_DIMM_MODE_OEM strap</desc>
          </field>
      </data>
      <hsd url="https://hsdes.intel.com/appstore/article/#/14020523387">[DMR-CCB] Support 1 DIMM per socket as POR configuration for Oak Stream</hsd>
    </command>
    <command>
      <name>CR_PROXY</name>
      <opcode>0x7b</opcode>
      <desc>This command enables BIOS to read and write a specified set of 32-bit control registers.</desc>
      <bwg>Yes</bwg>
      <interface>
        <field>
          <name>READ_WRITE</name>
          <lsb>8</lsb>
          <num_bits>1</num_bits>
          <enum desc="READ" key="READ" val="0x0"/>
          <enum desc="WRITE" key="WRITE" val="0x1"/>
        </field>
        <field>
          <name>CR_INDEX</name>
          <lsb>9</lsb>
          <num_bits>8</num_bits>
          <desc>Specifies the control register index.</desc>
        </field>
        <field>
          <name>CR_INSTANCE</name>
          <lsb>17</lsb>
          <num_bits>8</num_bits>
          <desc>Specifies the instance for multi-instance control registers.</desc>
        </field>
        <field>
          <name>CR_CHAN_INDEX</name>
          <lsb>25</lsb>
          <num_bits>4</num_bits>
          <desc>Specifies the channel index for MC control registers.</desc>
        </field>
      </interface>
      <data dir="in">
        <field>
          <name>DATA</name>
          <lsb>0</lsb>
          <num_bits>32</num_bits>
          <desc>Register value to write</desc>
        </field>
      </data>
      <data dir="out">
        <field>
          <name>DATA</name>
          <lsb>0</lsb>
          <num_bits>32</num_bits>
          <desc>Read register value</desc>
        </field>
      </data>
      <notes>
        This command is used to expose specific registers to BIOS to workaround access policy defects.
        BIOS never receives direct addressability, rather registers are assigned an index and translation logic is added to the Pcode/Primecode FW.

        List of supported registers:
        **DMR: No registers are currentl defined**

        If a CR_INDEX is not supported on a die, the PM agent will respond with NOT_SUPPORTED_ON_THIS_DIE.
      </notes>
    </command>
    <command>
      <name>MISC_WORKAROUND_ENABLE</name>
      <opcode>0x7c</opcode>
      <desc>This command enables BIOS to select/apply various workarounds</desc>
      <bwg>Yes</bwg>
      <data dir="in">
        <field>
          <name>WA_INDEX</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <desc>Index of the workaround (see documentation)</desc>
          <!-- <enum desc="ADL DDR MC workaround HSD14018931184" key="ADL_DDR_MC_WA" val="0x01" /> -->
          <!-- <enum desc="Initialize UPI L1 QSCD timer value workaround" key="INIT_UPI_QSCD_TIMER" val="0x2" /> -->
          <!-- <enum desc="Row Hammer fix for pTRR" key="ROW_HAMMER_FIX" val="0x5" /> -->
          <!-- <enum desc="CXL bifurcation workaround" key="CXL_BIFURCATION_WA" val="0x6" /> -->
          <!--<enum desc="CXL test card PkgS workaround" key="CXL_TEST_CARD_PKGS_WA_ENABLE" val="0x8" />-->
          <!-- <enum desc="PRS_CAP_DISABLE workaround" key="PRS_CAP_DISABLE_WA" val="0xE" /> -->
        </field>
        <field>
          <name>WA_PARAM1</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc>Param1 for the workaround (see documentation)</desc>
        </field>
        <field>
          <name>WA_PARAM2</name>
          <lsb>16</lsb>
          <num_bits>8</num_bits>
          <desc>Param2 for the workaround (see documentation)</desc>
        </field>
      </data>
      <notes>The list of supported workarounds will be unique to each Product/Stepping

        > Note: For DMR this list needs to get reviewed. By default Workaround are not propigated forward.

        Error codes:

        * MAILBOX_BIOS_RETURN_CODE_NONE
        * MAILBOX_BIOS_ERROR_CODE_INVALID_WORKAROUND
      </notes>
    </command>
    <command>
      <name>IOMT_CTL</name>
      <opcode>0xd9</opcode>
      <desc>Controls IO-Margining Tool (IOMT) feature</desc>
      <bwg>No</bwg>
      <die type="IO"/>
      <mbox_access access_type="RW" mbox="OS" />
      <interface>
        <field>
          <name>READ_WRITE</name>
          <lsb>8</lsb>
          <num_bits>1</num_bits>
          <enum desc="READ" key="READ" val="0x0"/>
          <enum desc="WRITE" key="WRITE" val="0x1"/>
        </field>
      </interface>
      <data dir="out" key="READ">
        <field>
          <name>LOCK</name>
          <lsb>0</lsb>
          <num_bits>1</num_bits>
          <desc>Indicates the interface is locked</desc>
        </field>
        <field>
          <name>IOMT_EN</name>
          <lsb>1</lsb>
          <num_bits>1</num_bits>
          <desc>If set, indicates IOMT is enabled</desc>
        </field>
      </data>
      <data dir="in" key="WRITE">
        <field>
          <name>LOCK</name>
          <lsb>0</lsb>
          <num_bits>1</num_bits>
          <desc>Lock bit can only be set, it is cleared on reset. The lock bit is automatically set by FW after BIOS CPL2</desc>
        </field>
        <field>
          <name>IOMT_EN</name>
          <lsb>1</lsb>
          <num_bits>1</num_bits>
          <desc>BIOS sets IOMT_EN to enable the IO-Margining Tool</desc>
        </field>
      </data>
      <notes>
        **IOMT-CTL Write**
        This sub-command is used by BIOS to enable the IO-Margining Tool (IOMT) feature.
        Any write of IOMT_CTL will result in the lock bit being set by Primecode. Primecode will update the data field to indicate the lock bit is set even if BIOS doesn't set it.
        Primecode will unconditionally set the lock bit at CPL2 if BIOS has not opted into the feature.
        Writes when the lock bit is set will be ignored this command will always return a NO_ERROR completion.

        **IOMT-CTL Read**
        This sub-command is used by MCHECK to determine if the IO-Margining Tool (IOMT) feature is enabled. This command will always return a NO_ERROR completion.
      </notes>
    </command>
    <command>
      <name>VDD_RAMP</name>
      <opcode>0x80</opcode>
      <desc>Trigger the ramp of a DRAM VR to a desired voltage.</desc>
      <bwg>Yes</bwg>
      <die type="IO"/>
      <interface>
        <field>
          <name>ADDR</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc>Physical VR address. Format: 5 bits - 1 bit bus addr + 4 bit VR addr. Remaining (8 - 5) bits should be 0. Eg: 0x10, 0x11</desc>
        </field>
      </interface>
      <data dir="in">
        <field>
          <name>SVID_DATA</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <desc> The data should be in MBVR VID format. Eg: If the desired voltage is 1.12V, field should contain 0x3F if MBVR is in 10mV stepping, 0xAF if MBVR is in 5mV stepping. </desc>
        </field>
        <field>
          <name>WRITE_OFFSET</name>
          <lsb>31</lsb>
          <num_bits>1</num_bits>
          <desc />
        </field>
      </data>
      <notes>This command is used to trigger the ramp of a DRAM VR to a desired voltage. BIOS must pass to pcode the value DRAM VR must ramp up to in the DATA register in MBVR VID format (8-bit VID in SVID format). The particular VR being targeted is indicated by the VR Addr field in the INTERFACE register.
        Bounds check will be done prior to triggering the ramp of a DRAM VR. Primecode will MCA if bounds check fails. Bounds check will not be done in overclocking scenarios.

        BIOS may optionally set bit 31 in the data field to write to the offset register in the VR prior to commanding a Vdd ramp. The offset data is in
        SVID format - an 8 bit binary 2's complement offset value, in VID ticks. This is useful for setting a Vdd &gt; 1.52V, the usual maximum programmable VID. Writing to offset register is only valid for overclocking scenarios.

        The VR Addr is the physical VR address as per the SVID topology of the SOC.

        Error codes:

        * NO_ERROR
        1) If command executed successfully.
        * ILLEGAL_DATA
        1) If input VR address is not a valid DRAM VR address.
        2) If WRITE_OFFSET bit is set when Overclocking is not enabled.
        * INVALID_COMMAND
        1) If SVID IP is not present.
      </notes>
    </command>
    <command>
      <name>ADDDC_QUIESCE</name>
      <opcode>0x81</opcode>
      <desc>Adaptive Double Device Data Correction - Quiesce and Failover</desc>
      <bwg>Yes</bwg>
      <die type="IO"/>
      <mbox_access access_type="RW" mbox="BMC" />
      <interface>
        <field>
          <name>SUB_COMMAND</name>
          <lsb>8</lsb>
          <num_bits>4</num_bits>
          <desc>0 - SPARE_ENABLE, 1 - MC_FAILOVER_TADBASE_PROG(Deprecated for GNR) 2 - GNR HBM Sparing 3- sPPR </desc>
          <enum desc="Spare enable logic" key="SPARE_ENABLE" val="0x0" bwg="Yes"/>
          <enum desc="Programming the TADBASE registers" key="MC_FAILOVER_PROG" val="0x1" bwg="Yes"/>
          <!--enum desc="GNR HBM Sparing" key="GNR_HBM_SPARING" val="0x2" bwg="?"/-->
          <enum desc="Runtime sPPR" key="sPPR" val="0x3" bwg="?"/>
        </field>
        <field>
          <name>MC_INDEX</name>
          <lsb>12</lsb>
          <num_bits>6</num_bits>
          <desc>MC instance, the number of instance can go up to 12 on DMR</desc>
        </field>
        <field>
          <name>SPPR_TIMEOUT</name>
          <lsb>18</lsb>
          <num_bits>8</num_bits>
          <desc>Wait Time for the sPPR flow</desc>
        </field>
        <field>
          <name>DDR_SUB_CHANNEL</name>
          <lsb>26</lsb>
          <num_bits>1</num_bits>
          <desc>Indicates which DDR Sub-Channel should be involved in the flows</desc>
        </field>
      </interface>
      <notes>
        This command had two features being implemented in as single command.

        1.  ADDDC (Adaptive double device data correction):
        This is the case when the device has failures and the traffic on that device has to be quiesced.
        In this time, the hardware will try to initiate corrected memory error handling. If the device has the reached the threshold for the number of errors then the device
        has been declared to be beyond repair and the hardware will copy all the data on the bad device on the spare device. The traffic henceforth will be routed to
        the spare device. This process happens in a lock step fashion.
        BIOS cannot program the CRs for rerouting of the traffic to the spare device. Hence this feature is implemented as a BIOS to Mailbox command.
        The system can sustain two device failures. Along with the primary device, there is a spare device and a parity device (the one used for error correction). When
        the first device fails, the spare device becomes the primary device and the parity device is still used for error correction. On second device failure, the
        system gives user an indication that the bad devices should be changed.

        2.  MC mirroring and failover:
        The data accesses on the memory device are being mirroed on a 2 channels. The read accesses are routed thourgh the primary
        memory channel and the writes go to primary and backup memory channel both. In case of a channel failover, the the backup channel is being used. When an error
        is detected in primary location, ECC error correction is applied on the primary location. If it is an uncorrectable error then the data from the secondary
        location is used to fulfill the request.
        Mirror Scrub: Also data from the secondary location is copied to the primary location and re-read. This is called mirror scrub. if the re-read data is good a
        memory corrected error is reported. CE because error corrected by HW RAS. BIOS can enable the event reporting via SMI/CMCI/ERR0. If the re-read data is bad then
        a memory uncorrected error is reported. BIOS can enable the event reporting via SMI/MC/ERR1.
        Permanent mirror failover: Refers to an error on a mirrored memory location that couldn't be corrected using a mirror scrub. The channel is being removed from
        the system.
        The MC mirror failoevr and TAD register programming was done by Pcode in Skylake, in 10nm it is moved to BIOS.

        3.  sPPR
        need description


        Error Codes:

        * NO_ERROR
        * ILLEGAL_DATA
        * ILLEGAL_SUBCOMMAND
        * BAD_MC_INDEX
        * TIMEOUT
        * SPPR FAIL


        Flow of the command:

        1. Input Parameter check

        if (MC_index not in GLOBL_TOPO_ENABLED_MASKS_MC &amp;&amp; GLOBAL_TOPO_ENABLED_MASKS_SCF_MEM)
        {
        Error_code = BAD_MC_INDEX
        return
        }

        if (Sub_cmd &gt;= %NO_OF_SUB_CMD_RAS_QUIESCE_UNQUIESCE)
        {
        Error_code = ILLEGAL_SUBCOMMAND
        }

        2. Quiesce the MC

        3. Wait for it to be quiesced

        4. Timeout if it does not quiesce within 40 usecs otherwise continue with TADBASE or ADDDC_fix subcommand

        5. Execute SUB_COMMAND specific behavior

        if Sub_cmd == 0
        {
        // adddc fix
        Set MC sparing_control.spare_enable = 0x1
        }
        else if Sub_cmd == 1
        {
        // MC failover and tadbase programming feature
        Set B2CMI MirrorFailover.Ddr4ChnlFailed = 0x1
        }
        else if Sub_cmd ==3
        {
        Set MC mcmtr.close_pg=0x0
        Set MC sPPR_ctrl0.start_inprogress = 1
        poll on sPPR_ctrl0.start_inprogress == 0-> If times out , set ERROR CODE = TIMEOUT
        Set MC mcmtr.close_pg=(page_policy)
        if ( sPPR_ctrl0.success_failed == 1 )
        {
        set ERROR CODE = NO _ERROR
        }
        else
        {
        set ERROR CODE = SPPR FAIL
        }
        }

        6. Unquiesce the MC
      </notes>
    </command>
    <command>
      <name>QUIESCE_PECI</name>
      <opcode>0x8c</opcode>
      <desc>Preventing OOB-MSM TOCTOU attack on Alias Checking Module</desc>
      <bwg>No</bwg>
      <lock_event type="cpl_phase" lock="PH3"/>
      <die type="IO"/>
      <mbox_access access_type="RW" mbox="OS" />
      <notes>ACM shall use OS2P Mailbox MSRs to initiate QUIESCE_PECI commands. ACM is invoked by BIOS and completed before RST_CPL3.

        This command is locked after RST_CPL3 is completed. Access after RST_CPL3 will result in an INVALID_COMMAND response.

        A change for DMR, Primecode must clear PECI_DOMAIN_ID_TBL_CONFIG.enabled = 1'b0 on Quiesce and during unquisece Primecode must set PECI_DOMAIN_ID_TBL_CONFIG.enabled = 1'b1 to re-enable PECI flows
      </notes>
      <hsd url="https://hsdes.intel.com/appstore/article/#/14021094942">Update to PECI Quiesce BIOS2PCODE Mailbox</hsd>
    </command>
    <command>
      <name>UNQUIESCE_PECI</name>
      <opcode>0x8d</opcode>
      <desc>Preventing OOB-MSM TOCTOU attack on Alias Checking Module</desc>
      <bwg>No</bwg>
      <lock_event type="cpl_phase" lock="PH3"/>
      <die type="IO"/>
      <mbox_access access_type="RW" mbox="OS" />
      <notes>ACTM shall use OS2P Mailbox MSRs to initiate QUIESCE_PECI commands. ACTM is invoked by BIOS and completed before RST_CPL3.

        This command is locked after RST_CPL3 is completed. Access after RST_CPL3 will result in an INVALID_COMMAND response.

        When this command is issued, primecode will set OOB-MSM LTM_PATCH_CTRL_REGISTER.Pause_LTM = 1'b0
      </notes>
    </command>
    <command>
      <name>READ_PM_CONFIG</name>
      <opcode>0x94</opcode>
      <desc>Read PM Configuration</desc>
      <bwg>Yes</bwg>
      <mbox_access access_type="RW" mbox="OS" />
      <interface>
        <field>
          <name>SUB_COMMAND</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc> - </desc>
          <enum desc="Configure MIN ICCP level knob for the Config TDP slowloop" key="MIN_ICCP_LEVEL" val="0x2" bwg="Yes"/>
          <enum desc="Configure SSC CONTROL Programming" key="PROG_SSC_CONTROL" val="0x7" bwg="Yes"/>
          <enum desc="Autonomous Idle feature for IO stacks. Not valid for DMR" key="AUTO_IDLE_IO" val="0x8" bwg="No"/>
          <enum desc="Configure UFS Scalability Optimization Disable knob. Not valid for DMR" key="UFS_OPTIMIZATION_DISABLE" val="0x9" bwg="No"/>
        </field>
      </interface>
      <data dir="out" key="MIN_ICCP_LEVEL" storage="patch">
        <name> MIN_ICCP_LEVEL </name>
        <field>
          <name>LEVEL</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <desc>Minimum ICCP Level that should be used by the IA Core.

            On writes, the final ICCP License used is the max of this field and a fused MIN_ICCP_LEVEL.

            A read returns the resolved MIN ICCP Level. If a read occurs before a write it will return the fused MIN_ICCP_LEVEL.
          </desc>
        </field>
      </data>
      <data dir="out" key="PROG_SSC_CONTROL">
        <name>PROG_SSC_CONTROL</name>
        <field>
          <name>SSC_CONTROL</name>
          <lsb>0</lsb>
          <num_bits>1</num_bits>
          <desc>Control spread spectrum clocking</desc>
          <enum desc="SSC Control Disabled" key="DISABLED" val="0x0"/>
          <enum desc="SSC Control Enabled" key="ENABLED" val="0x1"/>
        </field>
      </data>
      <data dir="out" key="AUTO_IDLE_IO" storage="reset">
        <name>AUTO_IDLE_IO</name>
        <field>
          <name>DISABLE</name>
          <lsb>0</lsb>
          <num_bits>1</num_bits>
          <desc>Autonomous Idle feature for IO stacks</desc>
          <enum desc="Autonomous Idle Feature is Disabled" key="DISABLE" val="0x1" />
          <enum desc="Autonomous Idle Feature is Enabled" key="ENABLE" val="0x0" />
        </field>
      </data>
      <data dir="out" key="UFS_OPTIMIZATION_DISABLE" storage="patch">
        <name>UFS_OPTIMIZATION_DISABLE</name>
        <field>
          <name>DATA</name>
          <lsb>0</lsb>
          <num_bits>1</num_bits>
          <desc>UFS Scalability Optimization Disable </desc>
          <enum desc="UFS Scalability Feature is Disabled" key="DISABLE" val="0x1" />
          <enum desc="UFS Scalability Feature is Enabled" key="ENABLE" val="0x0" />
        </field>
      </data>
      <notes>This command is used to configure miscellaneous options.</notes>
    </command>
    <command>
      <name>WRITE_PM_CONFIG</name>
      <opcode>0x95</opcode>
      <desc>Write PM Configuration</desc>
      <bwg>Yes</bwg>
      <mbox_access access_type="RW" mbox="OS" />
      <interface>
        <field>
          <name>SUB_COMMAND</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc> - </desc>
          <enum desc="Configure MIN ICCP level knob for the Config TDP slowloop" key="MIN_ICCP_LEVEL" val="0x2" bwg="Yes"/>
          <enum desc="Configure SSC CONTROL Programming" key="PROG_SSC_CONTROL" val="0x7" bwg="Yes"/>
          <enum desc="Configure Autonomous Idle feature for IO stacks. Not valid for DMR" key="AUTO_IDLE_IO" val="0x8" bwg="No"/>
          <enum desc="Configure UFS Scalability Optimization Disable knob. Not valid for DMR" key="UFS_OPTIMIZATION_DISABLE" val="0x9" bwg="No"/>
        </field>
      </interface>
      <data dir="in" key="MIN_ICCP_LEVEL" storage="patch">
        <duplicate command="READ_PM_CONFIG" dir="out">MIN_ICCP_LEVEL</duplicate>
      </data>
      <data dir="in" key="PROG_SSC_CONTROL">
        <duplicate command="READ_PM_CONFIG" dir="out">PROG_SSC_CONTROL</duplicate>
      </data>
      <data dir="in" key="AUTO_IDLE_IO">
        <duplicate command="READ_PM_CONFIG" dir="out">AUTO_IDLE_IO</duplicate>
      </data>
      <data dir="in" key="UFS_OPTIMIZATION_DISABLE">
        <duplicate command="READ_PM_CONFIG" dir="out">UFS_OPTIMIZATION_DISABLE</duplicate>
      </data>
      <notes>This command is used to configure miscellaneous options.</notes>
    </command>
    <command>
      <name>RAS_START</name>
      <opcode>0x9a</opcode>
      <desc>Enter in to a safe state for RAS flows </desc>
      <bwg>Yes</bwg>
      <die type="IO"/>
      <mbox_access access_type="RW" mbox="BMC" />
      <notes>
        This command is used to keep the package in PkgC0 state during RAS events.

        There are multiple interfaces that can signal a RAS START condition. Primecode will keep track of which interfaces issued a RAS_START and will only revert back to normal operation if the equivalent set of interfaces issued a RAS_EXIT.
      </notes>
    </command>
    <command>
      <name>RAS_EXIT</name>
      <opcode>0x9b</opcode>
      <desc>Exit the RAS state</desc>
      <bwg>Yes</bwg>
      <die type="IO"/>
      <mbox_access access_type="RW" mbox="BMC" />
      <notes>Remove conditions applied during the RAS entry flow.</notes>
    </command>
    <command>
      <name>FAST_RAPL_NSTRIKE_PL2_DUTY_CYCLE</name>
      <opcode>0x9d</opcode>
      <desc>Bios programs the Nstrike PL2 duty cycle for fast rapl.</desc>
      <bwg>Yes</bwg>
      <die type="IO"/>
      <data dir="in">
        <field>
          <name>DUTY_CYCLE</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <desc>Programmable Data</desc>
        </field>
      </data>
      <notes>BIOS programs the Nstrike PL2 duty cycle for fast rapl. (write only)

        BIOS programmed data (8 bits)
        0 =  00000000 - 0%
        255 =  11111111 - 100%

        Pcode will clip the data to a programmable range. Programmable range is 25 (10%) to 64 (25%). Limits are enforced by pcode.</notes>
    </command>
    <command>
      <name>SET_MC_FREQ</name>
      <deprecated project="DMR"/>
      <opcode>0xa6</opcode>
      <desc>Used to set the MC frequency. </desc>
      <bwg>Yes</bwg>
      <lock_event type="cpl_phase" lock="PH3"/>
      <die type="IO"/>
      <mbox_access access_type="RW" mbox="OS" />
      <data dir="in">
        <field>
          <name>MC_RATIO</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <desc>MC PLL ratio in DCLK/100MHz</desc>
        </field>
        <field>
          <name>MC_FREQ_LOCK</name>
          <lsb>30</lsb>
          <num_bits>1</num_bits>
          <desc>Used to lock this command and provent further changes to the MC frequency. When set, the MC_RATIO field is ignored.</desc>
        </field>
      </data>
      <notes>
        > Note: This command is available via OS2P for MC Refresh Parameters Enforcement to lock out future frequency changes.
        >
        > When MC_FREQ_LOCK == 1, the MC_RATIO field is ignored. No change in frequency will occur and all MC_RATIO changes are locked out until the next reset.

        The MC_RATIO is provided in DCLK/100MHz (device clock). This is the base frequency of the IO pins and is half of the DDR Rate.

        These units are consistent with the CAPID definition for maximum transfer rate.

        For example:

        | DDR Frequency | DCLK | MC_RATIO |
        | ------------- | ---- | -------- |
        | DDR 5600      | 2800 | 28       |


        All enabled MCs will ramp to the ratio provided when this command is received.

        Pcode checks the requested ratio against maximum allowed ratio specified in the SST_PP_*_DMFC fuses

        DMFC fuse is a 7 bit fuse supporting upto 25.4 GT/s
        A DMFC fuse value = 0 is treated as no limit.

        This command returns the programmed ratio if successful.
      </notes>
    </command>
    <command>
      <name>READ_MC_FREQ</name>
      <deprecated project="DMR"/>
      <opcode>0xa7</opcode>
      <desc>Used to read the current MC frequency. It is also available via OS2P for MC Refresh Parameters Enforcement</desc>
      <bwg>Yes</bwg>
      <die type="IO"/>
      <mbox_access access_type="RW" mbox="OS" />
      <data dir="out">
        <field>
          <name>DIGITAL_VOLTAGE</name>
          <lsb>17</lsb>
          <num_bits>9</num_bits>
          <desc>Domain 0 voltage in U1.8 format</desc>
        </field>
        <field>
          <name>ANALOG_VOLTAGE</name>
          <lsb>8</lsb>
          <num_bits>9</num_bits>
          <desc>Domain 1 voltage in U1.8 format</desc>
        </field>
        <field>
          <name>MC_RATIO_ENCODING</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <desc>Ratio read from the dispatcher register. This is what pcode has previously programmed. To get ratio, multiple the encoding value by Refclk freq.</desc>
        </field>
      </data>
      <notes>This command is used by BIOS to read the MC_RATIO, Domain 0 (Digital)  and Domain 1 (Analog) voltages. </notes>
    </command>

    <command>
      <name>OC_TJ_MAX_OFFSET</name>
      <deprecated project="DMR"/>
      <!-- <deprecated project="DMR"/> -->
      <opcode>0xac</opcode>
      <desc>Specify new offset for TJMAX when overclocked</desc>
      <bwg>Yes</bwg>
      <interface>
        <field>
          <name>READ_WRITE</name>
          <lsb>8</lsb>
          <num_bits>1</num_bits>
          <desc/>
          <enum desc="Read current value" key="READ" val="0x0" bwg="Yes"/>
          <enum desc="Write new TJ Max offset" key="WRITE" val="0x1" bwg="Yes"/>
        </field>
      </interface>
      <data dir="in" storage="patch">
        <name>OC_TJ_MAX_OVERRIDE</name>
        <field>
          <name>TJMAX_OFFSET</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <precision>U8.0</precision>
          <desc>New TJ Max Offset value in &amp;deg;C</desc>
        </field>
      </data>
      <notes>This is a capability for BIOS to read or overwrite the TJ max offset fuse value for overclocking scenarios.

        This command is only available if:

        * OC_ENABLED fuse is set (i.e. OCing is enabled) and
        * Before pcode reaches the RST_CPL3 handler.

        Otherwise, this command will return a MAILBOX_BIOS_ERROR_CODE_INVALID_COMMAND error.

        In a read configuration, this command simply returns the current TJ max offset.

        In a write configuration, this command overwrites the TJ max offset fuse value.

        OPEN: TJMAX_OFFSET documention is inconsistent with the Primecode implementation, need to resolve and update this document.

        Note that, pcode checks the input offset value to make sure it is in allowed range. If requested offset is less than 20, pcode ceils it to 20 to make sure the TJ max on the platform is 105 C.

      </notes>
    </command>
    <command>
      <name>SET_CORE_MESH_RATIO</name>
      <opcode>0xaf</opcode>
      <desc>This command enables BIOS to change core/mesh ratio during reset</desc>
      <bwg>Yes</bwg>
      <lock_event type="cpl_phase" lock="PH3"/>
      <interface>
        <field>
          <name>SUB_COMMAND</name>
          <lsb>8</lsb>
          <num_bits>4</num_bits>
          <desc>0 - ALL CORES, 1 - BSP CORE</desc>
          <enum desc="Program all cores to CORE_RATIO after clipping to Core-P1; mesh to mesh ratio after clipping to Mesh-P1" key="ALL_CORES" val="0x0" bwg="Yes"/>
          <enum desc="Return the clipped frequency of the BSP and Fabric ratios" key="READ" val="0x1" bwg="Yes"/>
          <enum desc="Program BSP core to CORE_RATIO after clipping to Core-Max Ratio and other cores to PN; mesh to mesh ratio after clipping to Mesh-P0 - this allows mesh turbo" key="BSP_TURBO" val="0x2" bwg="Yes"/>
        </field>
      </interface>
      <data dir="in">
        <field>
          <name>CORE_RATIO</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <desc>CBB IA core ratio</desc>
        </field>
        <field>
          <name>CBB_MESH_RATIO</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc>CBB Mesh ratio</desc>
        </field>
        <field>
          <name>IMH_IO_MESH_RATIO</name>
          <lsb>16</lsb>
          <num_bits>8</num_bits>
          <desc>IMH Mesh IO ratio</desc>
        </field>
        <field>
          <name>IMH_MEMORY_MESH_RATIO</name>
          <lsb>24</lsb>
          <num_bits>8</num_bits>
          <desc>IMH Mesh Memory ratio</desc>
        </field>
      </data>
      <data dir="out" key="READ">
        <field>
          <name>CORE_RATIO</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <desc>Resolved BSP Core frequency, after clipping the write version of this command with the P0/P1 ratio.</desc>
        </field>
        <field>
          <name>CBB_MESH_RATIO</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc>Resolved CBB Mesh ratio after clipping</desc>
        </field>
        <field>
          <name>IMH_IO_MESH_RATIO</name>
          <lsb>16</lsb>
          <num_bits>8</num_bits>
          <desc>Resolved IMH Mesh IO ratio after clipping</desc>
        </field>
        <field>
          <name>IMH_MEMORY_MESH_RATIO</name>
          <lsb>24</lsb>
          <num_bits>8</num_bits>
          <desc>Resolved IMH Mesh Memory ratio after clipping</desc>
        </field>
      </data>
      <notes>Enables BIOS to request new ratio for all IA Cores and Mesh.  The requested ratios are clipped to allowed ranges, and an immediate transition to the clipped
        requests is performed.  When the response is returned, the core and mesh will be at the new (clipped) frequencies. The motivation of the command is to allow the
        cores to boot faster for BIOS execution. The command is not allowed after CPL3 phase.

        > All sub_commands utilize the same data format.

        **ALL_CORES (sub_command 0):** change the frequency of ALL cores to a maximum of the P1 frequency. This ALL_CORES command is used if BIOS decides to wake mulitple threads to parallelize the flow.

        **BSP_TURBO (sub_command 2):** allows the System BSP to operate up to the P01 frequency, while the other cores are forced to Pn. This mode is used to speed up single threaded BIOS operations.

        > The Workhorse processors on the non BSP-die will also get forced to Pn

        **READ (sub_command 1):** returns the ratios after clipping to to P1/P0 depending on the previous sub-command used.

        > For the READ sub_command, the BSP-Die will respond with the read data. The other CBBs will respond with NOT_SERVICED_ON_THIS_DIE.
        > IMH will merge the CBB results with the local IO/MEM fabric ratios and return the data

      </notes>
    </command>

    <command>
      <name>READ_MC_VOLTAGE</name>
      <deprecated project="DMR"/>
      <opcode>0xb2</opcode>
      <desc>This command provides BIOS with MC VCCD in 3.13 format</desc>
      <bwg>Yes</bwg>
      <die type="IO"/>
      <data dir="out">
        <field>
          <name>VCCP</name>
          <lsb>0</lsb>
          <num_bits>16</num_bits>
          <desc />
        </field>
      </data>
      <notes>This cmd reads the value of VCCD active voltage for the MC</notes>
    </command>
    <command>
      <name>ENHANCED_ADR</name>
      <opcode>0xb4</opcode>
      <desc>This command enables BIOS to change core/mesh ratio for FAST ADR</desc>
      <bwg>Yes</bwg>
      <interface>
        <field>
          <name>SUB_COMMAND</name>
          <lsb>8</lsb>
          <num_bits>4</num_bits>
          <desc>SUB_CMD</desc>
          <enum desc="set up ADR ratio configs" key="SET_ADR_RATIO" val="0x0" bwg="?"/>
          <enum desc="set up ADR timeouts" key="SET_ADR_TIMEOUTS" val="0x1" bwg="?"/>
        </field>
      </interface>
      <data dir="in" key="SET_ADR_RATIO">
        <notes>Specify the target ratios when ADR is initiated. Will be bound by max available ratio, but will not be bound by any ongoing throttle operations. A ratio of 0 is corrected to P1 ratio.</notes>
        <field>
          <name>CBB_FABRIC_RATIO</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc>Core die Fabric frequency in 100MHz ratios</desc>
        </field>
        <field>
          <name>IMH_IO_FABRIC_RATIO</name>
          <lsb>16</lsb>
          <num_bits>8</num_bits>
          <desc>IO Fabric frequency in 100MHz ratios</desc>
        </field>
        <field>
          <name>IMH_MEMORY_FABRIC_RATIO</name>
          <lsb>24</lsb>
          <num_bits>8</num_bits>
          <desc>Memory Fabric frequency in 100MHz ratios</desc>
        </field>
      </data>
      <data dir="in" key="SET_ADR_TIMEOUTS">
        <notes>
          Set the timeout to wait for acks before moving on to the next ADR phase. (i.e. transitions between phase 1a, 1b, 2) before continuing.

          A value of 0 disables the timeouts ( wait indefinately ). Disabled is the default setting.
        </notes>
        <field>
          <name>TIMEOUT</name>
          <lsb>0</lsb>
          <num_bits>12</num_bits>
          <desc>ADR timeout in milliseconds. A value of 0 disables the timeout.</desc>
        </field>
      </data>
      <notes>Enables BIOS to adjust the desired ADR behavior. The fabric ratios and maximum timeouts can be tuned based on platform configuration

        Error codes:

        * MAILBOX_BIOS_RETURN_CODE_NONE</notes>
    </command>

    <command>
      <name>OOB_INIT_EPP</name>
      <opcode>0xb9</opcode>
      <desc>Write epp_init value to the variable</desc>
      <bwg>Yes</bwg>
      <die type="COMPUTE"/>
      <interface>
        <field>
          <name>READ_WRITE</name>
          <lsb>8</lsb>
          <num_bits>1</num_bits>
          <enum desc="Invalid, will return error" key="READ" val="0x0"/>
          <enum desc="" key="WRITE" val="0x1"/>
        </field>
      </interface>
      <data dir="in">
        <field>
          <name>HWP_EPP_INIT_VALUE</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <desc>Default EPP value for OOB mode</desc>
        </field>
      </data>
      <notes>This command allows BIOS to set initial default EPP value depending EPB setting.

        Error codes:
        * ILLEGAL_DATA if interface field READ_WRITE = 0 (ie Read)</notes>
    </command>
    <command>
      <name>MULTI_SKT_UPD</name>
      <deprecated project="DMR"/>
      <opcode>0xc5</opcode>
      <desc>Multi-Socket Updated</desc>
      <bwg>Yes</bwg>
      <interface>
        <field>
          <name>SUB_COMMAND</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc>Sub commands enumerated below</desc>
          <enum desc="" key="LATE_ACTION_REG_UPD" val="0x1" bwg="?"/>
        </field>
      </interface>
      <data dir="in">
        <field>
          <name>DATA_RESERVED</name>
          <lsb>0</lsb>
          <num_bits>32</num_bits>
          <desc>None</desc>
        </field>
      </data>
      <notes>
        > Note: MULT_SK_UPD is not current required on DMR

        When pCode receives this command, it issues the MULTI_SKT_UPD_REQ to all die and connected sockets. It is used to coordinate full platform quiesce.</notes>
    </command>
    <command>
      <name>IO_CONFIG</name>
      <opcode>0xc6</opcode>
      <desc>Configures IO die IPs. Returns BAD_STACK_ID completion code if the stack id received is invalid</desc>
      <bwg>Yes</bwg>
      <lock_event type="cpl_phase" lock="PH4"/>
      <die type="IO"/>
      <rsp_completion type="ONE_DIE_SUCCESSFUL"/>
      <interface>
        <field>
          <name>SUB_COMMAND</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc>0: PSF_BYPASS_ENABLE; 1: ISM_ENABLE</desc>
          <enum desc="PSF_BYPASS mux select by (de)asserting SPARE_CFG[0] in ISA_PIU5 endpoint" key="PSF_BYPASS_ENABLE" val="0x0" bwg="?"/>
          <enum desc="Enable ISM by asserting SPARE_CFG[1] in ISA_PIU5 endpoint" key="ISM_ENABLE" val="0x1" bwg="?"/>
        </field>
      </interface>
      <data dir="in" key="PSF_BYPASS_ENABLE">
        <field>
          <name>STACK_ID</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <desc>Stack_id to operate on</desc>
        </field>
        <field>
          <name>MUX_SEL</name>
          <lsb>8</lsb>
          <num_bits>1</num_bits>
          <desc>Mux select</desc>
          <enum desc="psf_bypass mux select = 0" key="SEL_0" val="0x0" />
          <enum desc="psf_bypass mux select = 1" key="SEL_1" val="0x1" />
        </field>
      </data>
      <data dir="in" key="ISM_ENABLE">
        <field>
          <name>STACK_ID</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <desc>Stack_id to operate on</desc>
        </field>
        <field>
          <name>ENABLE</name>
          <lsb>8</lsb>
          <num_bits>1</num_bits>
          <desc>Enable ISM</desc>
          <enum desc="Not supported. Primecode returns ILLEGAL_DATA completion code" key="DISABLE" val="0x0" />
          <enum desc="Enables ISM" key="ENABLE" val="0x1" />
        </field>
      </data>
      <notes>This command is locked after RESET_CPL stage 4 and will return INVALID_COMMAND</notes>
    </command>
    <command>
      <name>GET_PSYS_INFO</name>
      <opcode>0xce</opcode>
      <desc>The command enables BIOS to determine if PSYS device is present/not and to obtain the address of the PSYS device if present.</desc>
      <bwg>Yes</bwg>
      <die type="IO"/>
      <data dir="out">
        <field>
          <name>PSYS_PRESENT</name>
          <lsb>0</lsb>
          <num_bits>1</num_bits>
          <desc>Psys presence info</desc>
          <enum desc="Psys device not present" key="FALSE" val="0x0" />
          <enum desc="Psys device present" key="TRUE" val="0x1" />
        </field>
        <field>
          <name>PHYSICAL_ADDRESS</name>
          <lsb>8</lsb>
          <num_bits>5</num_bits>
          <desc>Physical address in the format: 5 bits - 1 bit bus addr + 4 bit VR addr.</desc>
        </field>
      </data>
      <notes>
        Primecode returns 0x1 in PSYS_PRESENT field of BIOS_MAILBOX_DATA register if PSYS device is found.
        If PSYS_PRESENT = 0x1, PHYSICAL_ADDRESS field is populated with address in the format: 5 bits - 1 bit bus addr + 4 bit VR addr.
        If PSYS_PRESENT = 0x0, PHYSICAL_ADDRESS field should be xxx (Dont care)

        Completion code:

        * NO_ERROR:  If command executed successfully.
        * INVALID_COMMAND: If SVID IP is not present. </notes>
    </command>
    <command>
      <name>PSYS_CONFIG</name>
      <opcode>0xcf</opcode>
      <desc>PSYS_CONFIG Command is sent to each socket to define the PSYS topology.</desc>
      <bwg>Yes</bwg>
      <lock_event type="cpl_phase" lock="PH3"/>
      <die type="IO"/>
      <data dir="in" storage="patch">
        <name>PSYS_CONFIG</name>
        <field>
          <name>SLAVE_NID_MASK</name>
          <lsb>0</lsb>
          <num_bits>8</num_bits>
          <desc>Node ID mask of the leaf sockets that are part of this Root Platform Psys Domain.
            This field is ignored when IS_ROOT = 0 </desc>
        </field>
        <!-- Note: PSYS_SENSOR_NID_MASK is under discussion for how to support 2x2 vs 1x4 configurations -->
        <!--        <field>
             <name>PSYS_SENSOR_NID_MASK</name>
             <lsb>8</lsb>
             <num_bits>8</num_bits>
             <desc>Bit mask of Nodes in this Psys Domain that contain PSYS Sensors. Used by Root to know how many Psys Power values to include in the RAPL calculation.
             This field is ignored when IS_ROOT = 0.
             </desc>
             </field>
             <field>
             <name>PSYS_ROOT_NID</name>
             <lsb>24</lsb>
             <num_bits>4</num_bits>
             <desc>Node ID Root PSYS agent. This field is necessary for a PSYS sensor owner to know where to send the Consumed Power.
             Thie field is ignored when HAS_PSYS_SENSOR = 0</desc>
             </field>
             <field>
             <name>HAS_PSYS_SENSOR</name>
             <lsb>30</lsb>
             <num_bits>1</num_bits>
             <desc>Indicating that this socket contains a PSYS sensor.</desc>
             <enum desc="Does not have a PSYS sensor" key="NO" val="0x0"/>
             <enum desc="Has a PSYS Sensor" key="YES" val="0x1"/>
             </field>
        -->
        <field>
          <name>IS_MASTER</name>
          <lsb>31</lsb>
          <num_bits>1</num_bits>
          <desc>Indicating that this socket is PSYS root.</desc>
          <enum desc="PSYS Leaf" key="PSYS_LEAF" val="0x0"/>
          <enum desc="PSYS Root" key="PSYS_ROOT" val="0x1"/>
        </field>
      </data>
      <notes>Platforms may have one or more PSYS sensors and PSYS domains. Each PSYS root monitors and controls the power of multiple sockets. BIOS will inform each Root of the associated lead nodes so that the root knows which sockets to send the PSYS Limit.

        Some platforms will have multilple PSYS sensors that are aggregated together to create a combined power consumption to be used for regulating platform power.
        Possible Configurations:

        * PSYS ROOT - Responsible for runing the PSYS RAPL algorithm and providing a PSYS LIMIT to all nodes in the PSYS domain.
        * PSYS SENSOR owner - Collects PSYS data and sends power consumption to its PSYS Root. Note the PSYS Root may be the same socket as the owner
        * PSYS LEAF - Receives PSYS limit from domain root and enforces frequency limit in the socket.

      </notes>
    </command>
    <command>
      <name>PM_MISC_CONTROL</name>
      <opcode>0xd0</opcode>
      <desc>Provide controls for Power Management</desc>
      <bwg>Yes</bwg>
      <mbox_access access_type="RW" mbox="OS" />
      <interface>
        <field>
          <name>SUB_COMMAND</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc>SUB_COMMAND</desc>
          <enum desc="configures window size for EWMA calcul." key="THERM_MONITOR_STATUS" val="0x20" bwg="?"/>
        </field>
        <field>
          <name>READ_WRITE</name>
          <lsb>24</lsb>
          <num_bits>1</num_bits>
          <enum desc="READ" key="READ" val="0x0"/>
          <enum desc="WRITE" key="WRITE" val="0x1"/>
        </field>
      </interface>
      <data dir="in" key="THERM_MONITOR_STATUS">
        <notes>The THERM_MONITOR_STATUS sub-command can be locked by an out-of-band agent through the TPMI OPC_THERMAL_MONITOR control register.
          When locked a write will return the ERR_INTERFACE_LOCKED_OBB completion status.

          &gt; This command is not serviced by the CBB. The Decay Factor is resolved in the root and sent to all die using the SOCKET_THERMAL HPM message.
        </notes>
        <field>
          <name>DECAY_FACTOR</name>
          <lsb>0</lsb>
          <num_bits>7</num_bits>
          <desc>Decay factor X
            Window size (TAU) EWMA clipped at 1ms and 100s</desc>
        </field>
        <field>
          <name>ENABLE_EWMA</name>
          <lsb>7</lsb>
          <num_bits>1</num_bits>
          <desc>enable bit for the feature</desc>
        </field>
        <field>
          <name>IB_LOCK</name>
          <lsb>30</lsb>
          <num_bits>1</num_bits>
          <desc>This bit is RO and will be ignored on a write. On read, this field indicates if the command is locked for BIOS access.</desc>
        </field>
      </data>
      <notes></notes>
    </command>
    <command>
      <name>DDR_MISC_CONTROL</name>
      <opcode>0xd3</opcode>
      <desc> The command will be used by BIOS to indicate which PMON addresses are valid or should be enabled.</desc>
      <bwg>Yes</bwg>
      <die type="IO"/>
      <interface>
        <field>
          <name>SUB_COMMAND</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <enum desc="" key="DDR_VR_PMON_ADDRESS" val="0x1" bwg="Yes"/>
        </field>
      </interface>
      <data dir="in" key="DDR_VR_PMON_ADDRESS" storage="patch">
        <name>DDR_VR_PMON_ADDRESS</name>
        <field>
          <name>PMON_ADDRESS_0</name>
          <lsb>0</lsb>
          <num_bits>7</num_bits>
          <desc></desc>
        </field>
        <field>
          <name>VALID_0</name>
          <lsb>7</lsb>
          <num_bits>1</num_bits>
          <desc>1 == Corresponding Address is valid</desc>
        </field>
        <field>
          <name>PMON_ADDRESS_1</name>
          <lsb>8</lsb>
          <num_bits>7</num_bits>
          <desc></desc>
        </field>
        <field>
          <name>VALID_1</name>
          <lsb>15</lsb>
          <num_bits>1</num_bits>
          <desc>1 == Corresponding Address is valid</desc>
        </field>
        <field>
          <name>PMON_ADDRESS_2</name>
          <lsb>16</lsb>
          <num_bits>7</num_bits>
          <desc></desc>
        </field>
        <field>
          <name>VALID_2</name>
          <lsb>23</lsb>
          <num_bits>1</num_bits>
          <desc>1 == Corresponding Address is valid</desc>
        </field>
        <field>
          <name>PMON_ADDRESS_3</name>
          <lsb>24</lsb>
          <num_bits>7</num_bits>
          <desc></desc>
        </field>
        <field>
          <name>VALID_3</name>
          <lsb>31</lsb>
          <num_bits>1</num_bits>
          <desc>1 == Corresponding Address is valid</desc>
        </field>
      </data>
      <notes>
        For GNR since all the DIMMs support VRoD and there is only VDDQ/VDD_HV VRs which power DDRIO, pCode can always use the telemetries coming from DDR VR PMONs for DRAM RAPL and DDR VR IMONs for Socket RAPL.
        ERROR CODE:
        NO_ERROR
      </notes>
    </command>
    <command>
      <name>PM_SECURITY_CONTROL</name>
      <opcode>0xd5</opcode>
      <desc>This command has only one subcommand, UPI_SAI_FILTER, opcode 0. Any other value in subcommand field will return INVALID_SUBCOMMAND (0x27).</desc>
      <bwg>Yes</bwg>
      <die type="IO"/>
      <mbox_access access_type="RW" mbox="OS" />
      <interface>
        <field>
          <name>SUB_COMMAND</name>
          <lsb>8</lsb>
          <num_bits>8</num_bits>
          <desc>This will take a single input parameter.Pcode will not allow this command after RST_CPL3 is completed and return the error code -INVALID_COMMAND. The input parameter will specify either ENABLE_FILTER or DISABLE_FILTER.</desc>
          <enum desc="For enabling or disabling filter" key="UPI_SAI_FILTER" val="0x0" bwg="Yes"/>
        </field>
      </interface>
      <data dir="in" key="UPI_SAI_FILTER">
        <field>
          <name>ENABLE_FILTER</name>
          <lsb>0</lsb>
          <num_bits>1</num_bits>
          <desc>Bit specifies if filter needs to be enabled or disabled.</desc>
          <enum desc="pcode does a RMW of the UPI_SAI_FILTER0 register in all enabled UPI instances (1 link per instance) to clear the correspondingOOB_MSM_UNTRUSTED_SAI,HOSTIA_BOOT_SAI and HOSTIA_SMM_SAI bits in the FILTER_31_0 bit field of this register.pcode does a RMW of the UPI_SAI_FILTER1 register in all enabled UPI instances (1 link per instance) to clear the correspondingOOBMSM_SAIbits in the FILTER_63-32bit field of this register.." key="DISABLE" val="0x0" />
          <enum desc="pcode does a RMW of the UPI_SAI_FILTER0 register in all enabled UPI instances (1 link per instance) to set the correspondingOOB_MSM_UNTRUSTED_SAI,HOSTIA_BOOT_SAI and HOSTIA_SMM_SAI bits in the FILTER_31_0 bit field of this register.pcode does a RMW of the UPI_SAI_FILTER1 register in all enabled UPI instances (1 link per instance) to set the correspondingOOBMSM_SAIbits in the FILTER_63-32bit field of this register." key="ENABLE" val="0x1" />
        </field>
      </data>
      <notes>
        All subcommands are marked as OS mailbox accessible.

        ACTM shall use OS2P Mailbox MSRs to initiate UPI_SAI_FILTER commands.Pcode will define a new OS2P command under PM_SECURITY_CONTROL - 0xd5 COMMAND: PM_SECURITY_CONTROL (0xd5)
        SAI values are defined in the 10nm Security HAS. OOB_MSM_UNTRUSTED_SAI (SAI value = 0xE) corresponds to bit position 0xE,HOSTIA_BOOT_SAI (SAI value = 0x4) corresponds to bit position 4, and HOSTIA_SMM_SAI(SAI value = 0x2)corresponds to bit position 2 in the FILTER_31_0 bit field andOOB_MSM_SAI corresponds to(SAI value = 0x3D) corresponds to bit position 0x1DFILTER_63_32 bit field.
        MAILBOX_UPI_SAI_FILTER_HANDLER
        { //Return error if this is equested after CPL3.
        if GLOBAL_BIOS_CPL_PCODE_DONE_BITS.RST_CPL3==1 //Bit3
        return INVALID_COMMAND
        //Filter enable or disable?
        is_filter_enable=BIOS_MAILBOX_DATA[0:0]

        dw0_rmw_value=1&lt;&lt;OOB_MSM_UNTRUSTED_SAI|1&lt;&lt;HOSTIA_BOOT_SAI|1&lt;&lt;
        HOSTIA_SMM_SAI
        dw1_rmw_value=1&lt;&lt;OOB_MSM_SAI

        if is_filter_enable
        //Enableactions
        for i=0;i&lt;upi_enabled_instances;i++
        KTILNi_CR_UPI_SAI_FILTER0=KTILNi_CR_UPI_SAI_FILTER0|dw0_rmw_value
        KTILNi_CR_UPI_SAI_FILTER1=KTILNi_CR_UPI_SAI_FILTER1|dw1_rmw_value
        else
        //Disableactionsfori=0;i&lt;upi_enabled_instances;i++
        KTILNi_CR_UPI_SAI_FILTER0=KTILNi_CR_UPI_SAI_FILTER0&amp;(~dw0_rmw_value)
        KTILNi_CR_UPI_SAI_FILTER1=KTILNi_CR_UPI_SAI_FILTER1&amp;(~dw1_rmw_value)
        end
        return0}
      </notes>
    </command>
    <command>
      <name>SPD_RECOVERY_CTL</name>
      <opcode>0xda</opcode>
      <desc> Allows to configure and handle SPD Bus error recovery </desc>
      <bwg>Yes</bwg>
      <mbox_access access_type="RW" mbox="BMC" />
      <interface>
        <field>
          <name>SUB_COMMAND</name>
          <lsb>8</lsb>
          <num_bits>4</num_bits>
          <desc>Operation to perform:</desc>
          <enum val="0x0" key="SPD_RECOVERY_DONE" desc="BIOS/BMC has finished recovery steps. Primecode clears the SPD recovery status" bwg="No"/>
          <enum val="0x1" key="SPD_RECOVERY_CHECK" desc="BIOS/BMC wants to check the SPD recovery need. Primecode sends the SPD recovery requirement status" bwg="No"/>
          <enum val="0x2" key="SPD_RECOVERY_CONFIG" desc="Configures SPD bus recovery" bwg="Yes"/>
          <enum val="0x3" key="ERR0_RELEASE" desc="FW driven mode is removed for Err0 and control give back to HW" bwg="No"/>
        </field>
        <field>
          <name>SPD_RECOVERY_ENABLE</name>
          <lsb>12</lsb>
          <num_bits>1</num_bits>
          <desc>Controls SPD_RECOVERY feature. Only valid for SPD_RECOVERY_CONFIG subcommand</desc>
          <enum val="0x0" key="SPD_RECOVERY_DISABLED" desc="(default)"/>
          <enum val="0x1" key="SPD_RECOVERY_ENABLED" desc=""/>
        </field>
        <field>
          <name>SMI_ERR0_SELECT</name>
          <lsb>13</lsb>
          <num_bits>1</num_bits>
          <desc>Control error reporting for SPD recovery. Only valid for SPD_RECOVERY_CONFIG subcommand</desc>
          <enum val="0x0" key="SMI" desc="(default)"/>
          <enum val="0x1" key="ERR0" desc=""/>
        </field>
      </interface>
      <data dir="in" size="32" key="SPD_RECOVERY_DONE">
        <field>
          <name>SPD0_RECOVERY_DONE</name>
          <lsb>0</lsb>
          <num_bits>1</num_bits>
          <desc>SPD0 bus recovery completed.</desc>
        </field>
        <field>
          <name>SPD1_RECOVERY_DONE</name>
          <lsb>1</lsb>
          <num_bits>1</num_bits>
          <desc>SPD1 bus recovery completed.</desc>
        </field>
        <field>
          <name>SPD2_RECOVERY_DONE</name>
          <lsb>2</lsb>
          <num_bits>1</num_bits>
          <desc>SPD2 bus recovery completed.</desc>
        </field>
        <field>
          <name>SPD3_RECOVERY_DONE</name>
          <lsb>3</lsb>
          <num_bits>1</num_bits>
          <desc>SPD3 bus recovery completed.</desc>
        </field>
        <field>
          <name>SPD4_RECOVERY_DONE</name>
          <lsb>4</lsb>
          <num_bits>1</num_bits>
          <desc>SPD4 bus recovery completed.</desc>
        </field>
        <field>
          <name>SPD5_RECOVERY_DONE</name>
          <lsb>5</lsb>
          <num_bits>1</num_bits>
          <desc>SPD5 bus recovery completed.</desc>
        </field>
        <field>
          <name>SPD6_RECOVERY_DONE</name>
          <lsb>6</lsb>
          <num_bits>1</num_bits>
          <desc>SPD6 bus recovery completed.</desc>
        </field>
        <field>
          <name>SPD7_RECOVERY_DONE</name>
          <lsb>7</lsb>
          <num_bits>1</num_bits>
          <desc>SPD7 bus recovery completed.</desc>
        </field>
      </data>
      <data dir="out" size="32" key="SPD_RECOVERY_CHECK">
        <field>
          <name>SPD0_RECOVERY_REQUIRED</name>
          <lsb>0</lsb>
          <num_bits>1</num_bits>
          <desc>SPD0 bus requires recovery.</desc>
        </field>
        <field>
          <name>SPD1_RECOVERY_REQUIRED</name>
          <lsb>1</lsb>
          <num_bits>1</num_bits>
          <desc>SPD1 bus requires recovery.</desc>
        </field>
        <field>
          <name>SPD2_RECOVERY_REQUIRED</name>
          <lsb>2</lsb>
          <num_bits>1</num_bits>
          <desc>SPD2 bus requires recovery.</desc>
        </field>
        <field>
          <name>SPD3_RECOVERY_REQUIRED</name>
          <lsb>3</lsb>
          <num_bits>1</num_bits>
          <desc>SPD3 bus requires recovery.</desc>
        </field>
        <field>
          <name>SPD4_RECOVERY_REQUIRED</name>
          <lsb>4</lsb>
          <num_bits>1</num_bits>
          <desc>SPD4 bus requires recovery.</desc>
        </field>
        <field>
          <name>SPD5_RECOVERY_REQUIRED</name>
          <lsb>5</lsb>
          <num_bits>1</num_bits>
          <desc>SPD5 bus requires recovery.</desc>
        </field>
        <field>
          <name>SPD6_RECOVERY_REQUIRED</name>
          <lsb>6</lsb>
          <num_bits>1</num_bits>
          <desc>SPD6 bus requires recovery.</desc>
        </field>
        <field>
          <name>SPD7_RECOVERY_REQUIRED</name>
          <lsb>7</lsb>
          <num_bits>1</num_bits>
          <desc>SPD7 bus requires recovery.</desc>
        </field>
      </data>
      <data size="32" key="SPD_RECOVERY_CONFIG">
        <notes>This subcommand is used to control the SPD_RECOVERY feature. The Enable and Error reporting is controlled through the INTERFACE register.
          The DATA payload is not used</notes>
        <field>
          <name>DATA_RESERVED</name>
          <lsb>0</lsb>
          <num_bits>32</num_bits>
          <desc>None</desc>
        </field>
      </data>
      <data size="32" key="ERR0_RELEASE">
        <notes>This subcommand is used to release the ERR0 pin after it has been serviced. The DATA payload is not used.</notes>
        <field>
          <name>DATA_RESERVED</name>
          <lsb>0</lsb>
          <num_bits>32</num_bits>
          <desc>None</desc>
        </field>
      </data>
    </command>
  </commands>
  <completion_codes>
    <completion_code>
      <name>NO_ERROR</name>
      <encoding>0x0</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>INVALID_COMMAND</name>
      <encoding>0x1</encoding>
      <desc>For bad cmd encodings</desc>
    </completion_code>
    <completion_code>
      <name>BAD_VR_ADDR</name>
      <encoding>0x2</encoding>
      <desc>For bad Vr Address</desc>
    </completion_code>
    <completion_code>
      <name>SVID_ERROR</name>
      <encoding>0x3</encoding>
      <desc>SVID error</desc>
    </completion_code>
    <completion_code>
      <name>UNSUPPORTED_UPI_FREQ</name>
      <encoding>0x4</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>INVALID_PARAMETERS</name>
      <encoding>0x5</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>BAD_DIMM_INDEX</name>
      <encoding>0x6</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>BAD_BW_SCALE</name>
      <encoding>0x7</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>COUNTER_NOT_ENABLED</name>
      <encoding>0x8</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>BAD_CHANNEL_INDEX</name>
      <encoding>0x9</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>BAD_RANK_INDEX</name>
      <encoding>0xa</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>INVALID_VR_WA_CMD</name>
      <encoding>0xb</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>VR_REG_READ_ERROR</name>
      <encoding>0xc</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>CPU_ONLY_RESET_LOCKED</name>
      <encoding>0xd</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>BAD_VR_MAP</name>
      <encoding>0xe</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>BAD_MODE</name>
      <encoding>0xf</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>BAD_VR_INDEX</name>
      <encoding>0x10</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>IIO_HAS_DISABLED</name>
      <encoding>0x11</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>INVALID_BGF_ID</name>
      <encoding>0x12</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>INVALID_BGF_RATIO</name>
      <encoding>0x13</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>UNSUPPORTED_UPI_PORT_ADDR</name>
      <encoding>0x14</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>TIMEOUT</name>
      <encoding>0x15</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>ILLEGAL_DATA</name>
      <encoding>0x16</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>VR_INTERFACE_LOCKED</name>
      <encoding>0x17</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>INVALID_PTRSEP_FORMAT</name>
      <encoding>0x18</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>BAD_MC_INDEX</name>
      <encoding>0x19</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>BAD_SMBUS_NUM</name>
      <encoding>0x1a</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>UNSUPPORTED_MC_FREQ</name>
      <encoding>0x1b</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>DISABLED_UPI_PORT</name>
      <encoding>0x1c</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>UNSUPPORTED_IIO_INSTANCE</name>
      <encoding>0x1d</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>SMBUS_VPP_PAUSE_TIMEOUT</name>
      <encoding>0x1e</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>RETRY_SMBUS_BUSY</name>
      <encoding>0x20</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>INVALID_WORKAROUND</name>
      <encoding>0x21</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>GENERAL_ERROR</name>
      <encoding>0x22</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>INVALID_RUN_TIME_STATES</name>
      <encoding>0x24</encoding>
      <desc>Run time states check failed.</desc>
    </completion_code>
    <completion_code>
      <name>LT_CHECK_FAIL</name>
      <encoding>0x25</encoding>
      <desc>LT security check failed. Memory may be locked.</desc>
    </completion_code>
    <completion_code>
      <name>COMMAND_NA_AT_BOOT</name>
      <encoding>0x26</encoding>
      <desc>Command is not available until patch is loaded</desc>
    </completion_code>
    <completion_code>
      <name>ILLEGAL_SUBCOMMAND</name>
      <encoding>0x27</encoding>
      <desc>SUB Command doesn't exist</desc>
    </completion_code>
    <completion_code>
      <name>ERR_INTERFACE_LOCKED_OBB</name>
      <encoding>0x28</encoding>
      <desc>In band thermal monitor filtering blocked by PECI/PCS</desc>
    </completion_code>
    <completion_code>
      <name>BAD_MEM_TYPE</name>
      <encoding>0x29</encoding>
      <desc>Command is deprecated</desc>
    </completion_code>
    <completion_code>
      <name>BAD_MC_CHAN_INDEX</name>
      <encoding>0x2a</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>NO_PMDOWN</name>
      <encoding>0x2b</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>NO_MDFIS_TRAINING_RUN</name>
      <encoding>0x2c</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>UNSUPPORTED_RLINK_PORT_ADDR</name>
      <encoding>0x2d</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>CMD_NOT_AVAIL_POST_BIOS_RESET</name>
      <encoding>0x2e</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>INCORRECT_IP_DISABLE_CONFIG</name>
      <encoding>0x2f</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>INVALID_PI5_INSTANCE_ID</name>
      <encoding>0x30</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>INVALID_PI5_PORTMASK</name>
      <encoding>0x31</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>PI5_IS_DMI</name>
      <encoding>0x32</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>BAD_STACK_ID</name>
      <encoding>0x33</encoding>
      <desc>Stack Id recieved for IO_CONFIG command is not valid</desc>
    </completion_code>
    <completion_code>
      <name>BAD_SCF_MEM_INSTANCE</name>
      <encoding>0x34</encoding>
      <desc>P2A mailbox is busy, retry again</desc>
    </completion_code>
    <completion_code>
      <name>INVALID_AVX_LICENSE</name>
      <encoding>0x35</encoding>
      <desc>none</desc>
    </completion_code>
    <completion_code>
      <name>UNSUPPORTED_COMMAND</name>
      <encoding>0x36</encoding>
      <desc>Feature is disabled/ not supported</desc>
    </completion_code>
    <completion_code>
      <name>SPPR_FAILED</name>
      <encoding>0x37</encoding>
      <desc>sPPR failure</desc>
    </completion_code>
    <completion_code>
      <name>NOT_SERVICED_ON_THIS_DIE</name>
      <encoding>0xFF</encoding>
      <desc>For Primecode Internal use case only. Not a valid completion code for BIOS.</desc>
    </completion_code>
  </completion_codes>
  <reg_spec>
    <mbox_access access_type="RW" mbox="BIOS" />
    <interface size="32">
      <field>
        <name>COMMAND</name>
        <lsb>0</lsb>
        <num_bits>8</num_bits>
        <desc>None</desc>
      </field>
      <field>
        <name>ADDR_RESERVED</name> <!--To distinguish from valid ADDR bits used per command-->
        <lsb>8</lsb>
        <num_bits>21</num_bits>
        <desc>None</desc>
      </field>
      <field>
        <name>RESERVED</name>
        <lsb>29</lsb>
        <num_bits>2</num_bits>
        <desc>None</desc>
      </field>
      <field>
        <name>RUN_BUSY</name>
        <lsb>31</lsb>
        <num_bits>1</num_bits>
        <desc>None</desc>
      </field>
    </interface>
    <data size="32">
      <field>
        <name>DATA_RESERVED</name> <!--To distinguish from valid DATA bits used per command-->
        <lsb>0</lsb>
        <num_bits>32</num_bits>
        <desc>None</desc>
      </field>
    </data>
  </reg_spec>
</mailbox>
